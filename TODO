
* No STIL info when using online
* Network threads stops quitting

application dir
cache dir
user dir

* /usr/share/chipmachine as maindir
* ~/.chipmachine as writable dir for
_files/
generated/<shaders>
index.dat
*.db

lua



Read DB into source_list.txt file
Make spcsets and hvsc work online out of the box

ALL playlists synced from server?

get_lists -> list names -> playlist db

pdb.get_list

if not synced then download

manually UPLOAD own lists

need to LOGIN : bind uid to username
LOGIN dialog from app

simple security, no pass, full UIDs never readable from rpc calls




PLAY LISTS
==========

Switch to/create playlist

HOTKEY -> Put selected playlist into prompt for editing. Enter selects it or creates new
Now F7 adds/removes to that playlist instead of favorites


TODO
----

* Show LUA error
* Parse DB in order

SONG INFO SERVER

calls:

add_favorite <path> <userid>
remove_favorite <path> <userid>
played_song <path> <userid>
<userid> = login <handle> <pass>

<stats> = get_stats <path>

get_list <listname> <lastdate>

operation:

Random userid generated by client on first run, used directly
Client can log in (register) to get a permanent id. 

sync

for each song in favorites
  if not exists in old favorits
    add on server

for each song in old favorites
  if not exists in favorites
    delete on server

filtering

filters.lua

NAME, set of formats

TAB to cycle filters    

PARTY MODE
----------

Tween probs: Pause and party red
release lock after song end wven if no new song
subsong++ -- when song not switched...


2 second grace only allows sub song?
only applies to songs started with ENTER



v1 SIMPLE
* Song must play for at least 60 seconds before new song can be selected, unless ALT is held


ALWAYS
* Queue remains with ENTER 






Own lock for fft 

SUBSONG does not work after ending in
USF64

Silence at start should have higher threshhold




DC and DS needs to rename libnames to lowercase




* Subtitle in USF64 (and dreamcast?)
* Old info returns if song cant be played
* position next info to right edge
* larger sizes on larger screen

* subsong grouping... RSN vs USF64 for instance.. search on subsongs?





----------------

BUGS

* PI cant always keep up with fft audio
* PI jerky scroll, high cpu when more than ~15 texts on search screen?

* Dont index secondary files
* Dont duplicate fonts
* openmpt type name too long
* Freeze when starting mods?
* Speed up inc search? Remember last set?

FX

* Scroll screens (& stars) left right
* Scroll stars up/down with playlist scrolling


GUI

* Edit playlist screen
* KEY brings up EDITOR of CURRENT list
* Can save to any list name and replaces old
* Find show playlist hits first

TABLE playlist
 NAME INDEX

TABLE plmapping
 PLINDEX IDX SONGINDEX




LUA

* Return/Input VECTOR = Table
*


pl = find('stardust memories')
play(pl)


InfoScreen.add('Hello')

function InfoScreen.add(text, x, y, scale, color)
	infoscreen_add(text, x, y, scale_color);
end


playlist.mt = {}

function Playlist.new()
	local pl = {}
	setmetatable(pl, Playlist.mt)
	return pl
end





struct SongData {
	string title;
	string composer;
	string format;
	string source;
	string url;
	uint64_t uniqueid;

};


class SongSequence {
	int count();
	SongData operator[](int index);
};

class SongList {


class InfoScreen {

	struct InfoText {
		std::string text;
		int x;
		int y;
		uint32_t color;
		float alpha;
		float size;
	}

	shared_ptr<InfoText> add_text(const std::string &text, int x, int y, Font &font, uint32_t color, float size)

	std::vector<std::shared_ptr<InfoText>> texts;

};


auto t = screen.add_text();

tween(t.x




class CommandParser {
public:
	typedef std::function<void(const std::vector<std::string> &args)> Function;

	struct Command {
		std::string name;
		Function callback;
	};

	CommandParser() {
		defineType('i', [](std::string &arg) -> bool {
			stoi(arg);
			return true;
		});
	}

	void defineType(char c, std::function<bool(std::string &arg)> verifier);

	void add(const std::string &name, const std::string &desc, Function f);

	vector<Command> matchCommands(const std::string &line);

	void applyCommand(const Command &cmd, const std::vector<std::string> &args);


	void parse(const std::string &line) {
/*
		auto parts = split(line);
		if(parts.size() < 1)
			return true;

		vector<Command*> foundCommands;

		int l = parts[0].length();
		for(auto &c : commands) {
			if(c.name.substr(l) == parts[0]) {
				foundCommands.push_back(&c);
			}
		}

		if(foundCommands.size() == 1) {
			for(int i=1; i<parts.size(); i++) {
				char c = command.args[i-1].type;
				auto verifier = types[c].verifier;
				verifier(parts[i]);
			}
			foundCommands[0].callback(parts);
		} else {
			for(auto &c : foundCommands) {
			}
		}*/
	}

};
