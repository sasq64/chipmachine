
SUBSONG does not work after ending in
USF64

Silence at start should have higher threshhold

DC and DS needs to rename libnames to lowercase




* Subtitle in USF65 (and dreamcast?)
* Old info returns if song cant be played
* position next info to right edge
* larger sizes on larger screen

* subsong grouping... RSN vs USF64 for instance.. search on subsongs?

BUGS

* PI cant always keep up with fft audio
* PI jerky scroll, high cpu when more than ~15 texts on search screen?

* Dont index secondary files
* Dont duplicate fonts
* openmpt type name too long
* Freeze when starting mods?
* Speed up inc search? Remember last set?

FX

* Scroll screens (& stars) left right
* Scroll stars up/down with playlist scrolling


GUI

* Edit playlist screen
* KEY brings up EDITOR of CURRENT list
* Can save to any list name and replaces old
* Find show playlist hits first

TABLE playlist
 NAME INDEX

TABLE plmapping
 PLINDEX IDX SONGINDEX




LUA

* Return/Input VECTOR = Table
*


pl = find('stardust memories')
play(pl)


InfoScreen.add('Hello')

function InfoScreen.add(text, x, y, scale, color)
	infoscreen_add(text, x, y, scale_color);
end


playlist.mt = {}

function Playlist.new()
	local pl = {}
	setmetatable(pl, Playlist.mt)
	return pl
end





struct SongData {
	string title;
	string composer;
	string format;
	string source;
	string url;
	uint64_t uniqueid;

};


class SongSequence {
	int count();
	SongData operator[](int index);
};

class SongList {


class InfoScreen {

	struct InfoText {
		std::string text;
		int x;
		int y;
		uint32_t color;
		float alpha;
		float size;
	}

	shared_ptr<InfoText> add_text(const std::string &text, int x, int y, Font &font, uint32_t color, float size)

	std::vector<std::shared_ptr<InfoText>> texts;

};


auto t = screen.add_text();

tween(t.x




class CommandParser {
public:
	typedef std::function<void(const std::vector<std::string> &args)> Function;

	struct Command {
		std::string name;
		Function callback;
	};

	CommandParser() {
		defineType('i', [](std::string &arg) -> bool {
			stoi(arg);
			return true;
		});
	}

	void defineType(char c, std::function<bool(std::string &arg)> verifier);

	void add(const std::string &name, const std::string &desc, Function f);

	vector<Command> matchCommands(const std::string &line);

	void applyCommand(const Command &cmd, const std::vector<std::string> &args);


	void parse(const std::string &line) {
/*
		auto parts = split(line);
		if(parts.size() < 1)
			return true;

		vector<Command*> foundCommands;

		int l = parts[0].length();
		for(auto &c : commands) {
			if(c.name.substr(l) == parts[0]) {
				foundCommands.push_back(&c);
			}
		}

		if(foundCommands.size() == 1) {
			for(int i=1; i<parts.size(); i++) {
				char c = command.args[i-1].type;
				auto verifier = types[c].verifier;
				verifier(parts[i]);
			}
			foundCommands[0].callback(parts);
		} else {
			for(auto &c : foundCommands) {
			}
		}*/
	}

};
